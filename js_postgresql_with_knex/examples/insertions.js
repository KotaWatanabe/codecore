// Before writing any queries with knex,
// require your client file.
const knex = require("../db/client");

{
  const query = knex
    .insert({
      title: "Top 10 Bugs",
      content: "Spider, ant, undefined is not an object"
    })
    .into("posts");

  // To look at the SQL generated by knex query without
  // execute the query, do:
  // console.log(query.toString());

  // To execute the query, do the following:
  // query.then(data => {
  //   // Execute a query is an asynchronous operation
  //   // just like fs.readFile, fs.writeFile, setTimeout, etc.
  //   // We need to pass callback to "then" which will be
  //   // called only once the query is complete.
  //   console.log(data);

  //   // When executing a query, knex opens connection
  //   // which will keep your programming forever until you close
  //   // the connection.

  //   // To close the connection, do:
  //   knex.destroy();
  // });
}

// When you insert multiple rows at a time, use
// insert with an array
// knex
//   .insert([
//     { title: "Top 5 Schools", content: "Hogwarts, CodeCore, etc" },
//     { title: "Top 3 Rocks", content: "Hogwarts, CodeCore, etc" },
//     { title: "Top 3 Programming Languages", content: "Hogwarts, CodeCore, etc" }
//   ])
//   .into("posts")
//   .returning("*")
//   .then(data => {
//     console.log(data);

//     knex.destroy();
//   });

// When running knex queries, you can set an environment
// variable to always the SQL querie that is sent to
// your db:

// In the line, we set the DEBUG env variable
// only for the command.
// DEBUG=knex:query node examples/insertions.js

const posts = Array.from({ length: 50 }).map((value, index) => {
  return {
    title: `Top ${index + 1} Things`,
    content: `Thing, `.repeat(index + 1) + "etc"
  };
});

knex
  .insert(posts)
  .into("posts")
  .then(() => {
    console.log("Added a bunch of posts!");
    knex.destroy();
  });
